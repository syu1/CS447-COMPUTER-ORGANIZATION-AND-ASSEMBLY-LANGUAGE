Project 4 - Multiplication and Division HardwareCS 0447 — Computer Organization & Assembly LanguageThe purpose of this project is for you to build 16-bit multiplication and 16-bit division hardwaresas we discussed in class inlogisim.Introduction to the Multiplication HardwareThe 16-bit multiplication hardware that we discussed in class is shown below:M_ReadyProduct321MultiplierMultiplicantMul16161ClockMultiplicationHardwareYou  can  consider  the  above  circuit  as  a  sub-circuit  namedmultiplicationwhich  contains  thefollowing input/output:•Multiplicand:  a 16-bit input•Multiplier:  a 16-bit input•Mul(1-bit input):  This input will be one if the instruction is the multiplication instruction•Clock(1-bit input)•Product(32-bit output)•MReady(1-bit output):  This output will be 1 if the product is readyNote that we require to have the outputMReadybecause the multiplication instruction will takemultiple clock cycles to produce a result.  Ideally, if a CPU see the instructionmul, it will set theappropriateMultiplicantandMultiplier.  Then, it will setMulto 1 and wait until the signalMReadyto turn to 1 before it continues to the next instruction.  The circuit inside will be the sameas the multiplication hardware discussed in class as shown below:MultiplicandShift leftProductWriteControl testShift rightMultiplier32 bits16 bits32−bit Adder32 bits1
Inside the multiplication hardware, you need three registers,Multiplicand(32-bit),Multiplier(16-bit),  andProduct(32-bit).   For  these  registers,  you  do  not  have  build  them  from  scratch.Simply use the register component under “Memory”.  Similarly, for the 32-bit adder, simply usethe  one  supplied  by  thelogisim.   Note  that  the  above  hardware  is  for  multiplying  two  16-bitnumbers and produce a 32-bit result.  The flowchart of this hardware is shown below:StartMultiplier01. Test1a. Add multiplicand to product andplace the result in Product register2. Shift the Multiplicand register left 1 bit3. Shift the Multiplier register right 1 bitDoneMultiplier0 = 1Multiplier0 = 0No: < 16 repetitionsYes: 16 recetitions16nd rep?Recall that in the first step, this hardware have to load the top 16-bit of themultiplicandregisterwith 0s and the bottom 16-bit withMultiplicand, load theproductregister with 0s, and load themultiplierregister with theMultiplier.  After all three registers are loaded with proper values,then the algorithm can start as follows.1.product=product+ (multiplicand∗multiplier0):  In this step, ifmultiplier0is 0, weactually performproduct=product+ 0.  But ifmultiplier0is 1, we performproduct=product+multiplicand.  This can be done by adding a 32-bit (2-input) multiplexer.  Thismultiplexer has two inputs, one from themultiplicandand another one is imply a 32-bit con-stant 0.  Simply use the Least Significant Bit (LSB) of themultiplierregister (multiplier0)to choose which one to go to the output as shown below:ProductMultiplicanduxm0multiplier0Notethat  before  the  algorithm  starts,  you  must  clear  theproductregister  which  can  bedone in two ways:2
(a)  by writing 0.  So, you also need another multiplexer to choose whether you want to write0 or output from 32-bit adder to theproductregister as shown below:MultiplicanduxmuxmProduct0multiplier00ClearProduct(b)  use theClearinput pin of the register.  Simply set it to 1 and the content will be cleared.2.  Shiftmultiplicandregister left one bit:  This step is simply update themultiplicandreg-ister by its data that has been shifted left by 1.  Simply use a Shifter provided bylogisimunder  Arithmetic.   Note  at  the  first  step  before  the  algorithm  starts,  you  need  to  updatemultiplicandregister by the inputMultiplicand. So, you need a multiplexer to select whichdata should go to themultiplicandregister (Multiplicandinput ormultiplicand<<1.The block diagram of the circuit is shown below:umxMultiplicandMultiplicand016163213.  Shiftmultiplierregister right one bit: This step is pretty much the same as in previous step.You need to be able to load the content of the multiplier or update it withmultiplier>>1Note  that  we  need  an  ability  to  control  what  to  do  at  each  clock  cycle.   For  example,  in  thefirst  clock  cycle,  we  need  to  load  contents  of  all  registers.   The  next  clock  cycle,  we  need  toperformproduct=product+ (multiplicand∗multiplier0).   The  third  clock  cycle,  we  needto  performmultiplicand=multiplicand<<1.   The  fourth  clock  cycle,  we  need  to  performmultiplier=multiplier>>2, and so on.  To be able to control each clock cycle, we will use acombination of counter and Read Only Memory (ROM) as shown below:ClockMulCounterROMMReadyWhenMulis 1, it will clear theCounterto 0.  At the same time, it will allow the clock signal togo to theCounter.  So, theCounterwill start counting up until its desired maximum value whichcan be set.  When it reaches its maximum value, itsCarrysignal will be 1 which can be used for3
the signalMReady.  The output of theCounterwill be use as the address of a ROM. The contentof the ROM will be control signal for each clock cycle.  In other words, you can program what doyou want to do at each clock cycle by content of the ROM.Notethat youMUSTset the maximum value of the counter to stay at a specific value basedon the number of clock cycles that your hardware uses.MAKE SUREthat the last output valueof the ROM should maintain the output of your product register.  When we grade your circuit, wewill simply put value of multiplicand and multiplier, and let the clock tick untilMReadyturn greenwithout stopping the clockand check the result.Introduction to the Division HardwareThe 16-bit division hardware that we discussed in class is shown below:16161ClockHardwareDivisorDividendQuotient11616RemainderDReadyDivisionDivYou can consider the above circuit as a sub-circuit nameddivisionwhich contains the followinginput/output:•Dividend:  a 16-bit input•Divisor:  a 16-bit input•Div(1-bit input):  This input will be one if the instruction is the division instruction•Clock(1-bit input)•Quotient(16-bit output)•Remainder(16-bit output)•DReady(1-bit output):  This output will be 1 if the product is readyThe division hardware that we discussed in class is shown below:Control test32 bits32 bits16 bitsQuotientDivisorWriteRemainderShift rightShift left32−bit AdderAgain, the above hardware is for dividing two 16-bit numbers and produce a 16-bit quotient and16-bit remainder.  The flowchart of this hardware is shown below:4
Start1. Subtract the Divisor register from theRemainder register and place theresult in the Remainder registerRemainderTest2b. Restore the original value by addingthe Divisor register to the Remainderregister and placing the sum in theRemainder register. Also shift theQuotient register to the left, setting thenew least significant bit to 03. Shift the Divisor register right 1 bitDone2a. Shift the Quotient register to the left,setting the new least significant bit 1Remainder >= 0Remainder < 0No: < 17 repetitionsYes: 17 repetitions17rdrepetition?The design concept of this division circuit will be pretty much the same as in multiplication circuitbut it requires more steps.  For example, when the subtraction result is less than 0, you have torestore to its original value by adding it back.  Another different is the quotient, sometime we shiftit left and insert a 0 but sometime we insert a 1.What to Do?For this project,  start with the given starter file namedmuldiv.circ.  This starter file containstwo sub-circuits,16-bit multiplicationand16-bit division.  In both sub-circuit, the counterand ROM are provided.  Simply build your multiplication and division circuits there.  Once you arefinish, put your circuits in themainand connect them with appropriate input/output.  We will testyour circuit from themaincircuit.Again, youMUSTset the maximum value of the counter to stay at a specific value based onthe number of clock cycles that each of your hardwares use.  We will not stop the clock when wecheck your results.SubmissionThe due date of this project is stated in the CourseWeb under this project.  Late submissions willnot be accepted.  You should submit the filemuldiv.circvia CourseWeb.
